
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - materials - cube refraction [Lucy]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background:#000;
        color:#fff;
        padding:0;
        margin:0;
        overflow:hidden;
        font-family:georgia;
        text-align:center;
      }
      a { color: #ff0080; text-decoration: none; }
      a:hover { color: #0080ff; }

      canvas { pointer-events:none; z-index:10; }

    </style>
  </head>

  <body>
    <script src="three.min.js"></script>

    <script src="Detector.js"></script>
    <script src="stats.min.js"></script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var FLOOR = -250;

      var container, stats;

      var camera, scene, renderer;
      var cameraCube, sceneCube, cubeTarget;

      var mesh, zmesh, geometry;

      var loader;

      var directionalLight, pointLight;

      var mouseX = 0, mouseY = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );
        camera.position.z = 2000;

        cameraCube = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100000 );

        scene = new THREE.Scene();
        sceneCube = new THREE.Scene();

        // LIGHTS

        var ambient = new THREE.AmbientLight( 0xffffff );
        scene.add( ambient );

        pointLight = new THREE.PointLight( 0xffffff, 2 );
        scene.add( pointLight );


       
        // material samples

        var r = "img/";

        var urls = [ r + "px.jpg", r + "nx.jpg",
               r + "py.jpg", r + "ny.jpg",
               r + "pz.jpg", r + "nz.jpg" ];

        var textureCube = THREE.ImageUtils.loadTextureCube( urls, new THREE.CubeRefractionMapping() );

        var cubeMaterial3 = new THREE.MeshBasicMaterial( { color: 0xccddff, envMap: textureCube, refractionRatio: 0.98, reflectivity:0.9 } );
        var cubeMaterial2 = new THREE.MeshBasicMaterial( { color: 0xccfffd, envMap: textureCube, refractionRatio: 0.985 } );
        var cubeMaterial1 = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.98, reflectivity:0.9 } )

        // light representation

        var sphere = new THREE.SphereGeometry( 100, 16, 8 );

        var mesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
        mesh.scale.set( 0.05, 0.05, 0.05 );
        pointLight.add( mesh );

        var material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.95 } );
        createScene( new THREE.SphereGeometry( 400, 32, 32 ), material, cubeMaterial2, cubeMaterial3 );

        // Skybox

        var shader = THREE.ShaderLib[ "cube" ];
        shader.uniforms[ "tCube" ].value = textureCube;

        var material = new THREE.ShaderMaterial( {

          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: shader.uniforms,
          depthWrite: false,
          side: THREE.BackSide

        } ),

        mesh = new THREE.Mesh( new THREE.BoxGeometry( 100000, 100000, 100000 ), material );
        sceneCube.add( mesh );

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );

        /*loader = new THREE.BinaryLoader( true );
        document.body.appendChild( loader.statusDomElement );

        loader.load( 'obj/lucy/Lucy100k_bin.js', function( geometry ) { createScene( geometry, cubeMaterial1, cubeMaterial2, cubeMaterial3 ) } );
        */
       
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2,
        windowHalfY = window.innerHeight / 2,

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        cameraCube.aspect = window.innerWidth / window.innerHeight;
        cameraCube.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      var group = new THREE.Group();

      function createScene( geometry, m1, m2, m3 ) {
        group = new THREE.Group();
        var s = 1.5, z = - 1000;

        var mesh = new THREE.Mesh( geometry, m1 );
        mesh.position.z = z;
        mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
        group.add( mesh );

       /* var mesh = new THREE.Mesh( geometry, m2 );
        mesh.position.x = - 900;
        mesh.position.z = z;
        mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
        group.add( mesh );

        var mesh = new THREE.Mesh( geometry, m3 );
        mesh.position.x = 900;
        mesh.position.z = z;
        mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
        group.add( mesh );*/

        scene.add(group);
        //loader.statusDomElement.style.display = "none";

      }

      function onDocumentMouseMove(event) {

        mouseX = ( event.clientX - windowHalfX ) * 4;
        mouseY = ( event.clientY - windowHalfY ) * 4;

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {

        var timer = -0.0002 * Date.now();
        var rotSpeed = .05;

        //camera.position.x += ( mouseX - camera.position.x ) * .05;
        //camera.position.y += ( - mouseY - camera.position.y ) * .05;

        var dx = ( mouseX - camera.position.x ) * .05;
        var dy = - mouseY - camera.position.y;

        //camera.position.x = camera.position.x * Math.cos(dx) + camera.position.z * Math.sin(dx);
        //camera.position.z = camera.position.z * Math.cos(rotSpeed) - camera.position.x * Math.sin(rotSpeed);

        

        //var time = Date.now() * 0.001;

        var rx = Math.sin( ( -mouseX - cameraCube.position.x ) * 0.000005 );
        var ry = Math.sin( ( -mouseY - cameraCube.position.y ) * 0.000005 );
          //ry = Math.sin( time * 0.3 ) * 0.5,
          //rz = Math.sin( time * 0.2 ) * 0.5;
        cameraCube.rotation.y += rx;
        cameraCube.rotation.x += ry;

        //cameraCube.rotation.y = ry;
        //cameraCube.rotation.z = rz;

        group.rotation.copy( camera.rotation );

        //group.position.x = 1500 * Math.cos( timer );
        //group.position.z = 1500 * Math.sin( timer );
        camera.lookAt( group.position );
        renderer.clear();
        renderer.render( sceneCube, cameraCube );
        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
