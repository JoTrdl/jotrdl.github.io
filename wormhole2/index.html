
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - materials - cube refraction [balls]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background:#777;
        padding:0;
        margin:0;
        font-weight: bold;
        overflow:hidden;
      }
    </style>
  </head>

  <body>
    <script src="three.min.js"></script>
    <script src="FresnelShader.js"></script>
    <script src="Detector.js"></script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var container;

      var camera, scene, renderer;
      var cameraCube, sceneCube;

      var mesh, lightMesh, geometry;
      var spheres = [];

      var directionalLight, pointLight;

      var mouseX = 0, mouseY = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      document.addEventListener( 'mousemove', onDocumentMouseMove, false );

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );
        camera.position.z = 3200;

        cameraCube = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );

        scene = new THREE.Scene();
        sceneCube = new THREE.Scene();

        var geometry = new THREE.SphereGeometry( 400, 32, 32 );

       /* var geometry = new THREE.LatheGeometry( [
          new THREE.Vector3(0,0,0),
          new THREE.Vector3(0,50,50),
          new THREE.Vector3(0,10,100),
          new THREE.Vector3(0,50,150),
          new THREE.Vector3(0,0,200) ] 
        );*/

   
        var path = "img/";
        var format = '.jpg';
        var urls = [
          path + 'px' + format, path + 'nx' + format,
          path + 'py' + format, path + 'ny' + format,
          path + 'pz' + format, path + 'nz' + format
        ];

        var textureCube = THREE.ImageUtils.loadTextureCube( urls, new THREE.CubeRefractionMapping() );
        var material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube, refractionRatio: 0.75, reflectivity:1 } );

        /*var shader = THREE.FresnelShader;
        var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
        uniforms[ "tCube" ].value = textureCube;

        var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms };
        var material = new THREE.ShaderMaterial( parameters ); 
      */
        for ( var i = 0; i < 1; i ++ ) {

          var mesh = new THREE.Mesh( geometry, material );

          //mesh.position.x = Math.random() * 10000 - 5000;
          //mesh.position.y = Math.random() * 10000 - 5000;
          //mesh.position.z = Math.random() * 10000 - 5000;

          mesh.scale.x = mesh.scale.y = mesh.scale.z = 1 * 3 + 1;

          scene.add( mesh );

          spheres.push( mesh );

        }

        // Skybox

        var path = "img/samples/";
        var format = '.jpg';
        var urls = [
          path + 'px' + format, path + 'nx' + format,
          path + 'py' + format, path + 'ny' + format,
          path + 'pz' + format, path + 'nz' + format
        ];
        textureCube = THREE.ImageUtils.loadTextureCube( urls, new THREE.CubeRefractionMapping() );
        var shader = THREE.ShaderLib[ "cube" ];
        shader.uniforms[ "tCube" ].value = textureCube;

        var material = new THREE.ShaderMaterial( {

          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: shader.uniforms,
          depthWrite: false,
          side: THREE.BackSide

        } ),

        mesh = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100 ), material );
        sceneCube.add( mesh );


        var geometry = new THREE.SphereGeometry(100000, 60, 40);
        var uniforms = {
          texture: { type: 't', value: THREE.ImageUtils.loadTexture('/img/milkyway.jpg') }
        };

        var vertex = [

          'varying vec2 vUV;',
          'varying float vDensity;',
          'varying float vDiff;',

          'void main() {',
          '  vUV = uv;',
          '  vec4 pos = vec4(position, 1.0);',
          '  gl_Position = projectionMatrix * modelViewMatrix * pos;',
          '}'

        ].join('\n');

        var fragment = [
          'uniform sampler2D texture;',
          'varying vec2 vUV;',

          'void main() {',
          '  vec4 sample = texture2D(texture, vUV);',
          '  gl_FragColor = vec4(sample.xyz, sample.w);',
          '}'

        ].join('\n');

        var material = new THREE.ShaderMaterial( {
          uniforms:       uniforms,
          vertexShader:   vertex,
          fragmentShader: fragment
        });

        skyBox = new THREE.Mesh(geometry, material);
        skyBox.scale.set(-1, 1, 1);
        skyBox.eulerOrder = 'XZY';
        skyBox.rotation.z = Math.PI/2;
        skyBox.rotation.x = Math.PI;
        skyBox.renderDepth = 3000.0;
        scene.add(skyBox);
        

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        container.appendChild( renderer.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2,
        windowHalfY = window.innerHeight / 2,

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        cameraCube.aspect = window.innerWidth / window.innerHeight;
        cameraCube.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function onDocumentMouseMove(event) {

        mouseX = ( event.clientX - windowHalfX ) * 10;
        mouseY = ( event.clientY - windowHalfY ) * 10;

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();

      }

      function render() {

        var timer = 0.0001 * Date.now();
        var rx = Math.sin( timer );
        var ry = Math.sin( timer );
        var rz = Math.sin( timer );

        for ( var i = 0, il = spheres.length; i < il; i ++ ) {

          var sphere = spheres[ i ];

          sphere.rotation.x = rx;
          sphere.rotation.y = ry;
          sphere.rotation.z = rz;

  
        }

        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y += ( - mouseY - camera.position.y ) * .05;

        camera.lookAt( scene.position );
        cameraCube.rotation.copy( camera.rotation );

        renderer.render( sceneCube, cameraCube );
        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
